% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/param_search.R
\name{feature_search}
\alias{feature_search}
\title{General search function}
\usage{
feature_search(attributes, fun, data, mode = c("greedy", "exhaustive"),
  type = c("forward", "backward"), subsetsSizes = 1:length(attributes),
  allowParallel = TRUE, ...)
}
\arguments{
\item{attributes}{Character vector with attributes names.}

\item{fun}{Function to evaluate. See Details.}

\item{data}{Data set for fun function.}

\item{mode}{String to determine which search to perform}

\item{type}{Argument for \code{mode = "greedy"}. Algorithm used for search.
Possible values are \code{forward} and \code{backward}.}

\item{subsetsSizes}{Argument for \code{mode = "exhaustive"}. Vector of sizes
of attributes subsets.}

\item{allowParallel}{Allow parallelization.}

\item{\dots}{Other arguments passed to foreach function.}
}
\description{
Convenience function wrapper for greedy and exhaustive algorithms for
searching atrribute subset space.
}
\examples{

# Enable parallelization in examples
 library(doSNOW) # doSNOW has an option for progress bar
 cl <- makeCluster(2)
 registerDoSNOW(cl)

# Close at the end
# stopCluster(cl)
# registerDoSEQ()

# 1) Evaluator from FSelector package.
evaluator <- function(subset, data, dependent = names(iris)[5]) {
  library(rpart)
  k <- 5
  splits <- runif(nrow(data))
  results <- sapply(1:k, function(i) {
    test.idx <- (splits >= (i - 1) / k) & (splits < i / k)
    train.idx <- !test.idx
    test <- data[test.idx, , drop = FALSE]
    train <- data[train.idx, , drop = FALSE]
    tree <- rpart(to_formula(subset, dependent), train)
    error.rate <- sum(test[[dependent]] != predict(tree, test, type = "c")) /
    nrow(test)
    return(1 - error.rate)
  })
  return(mean(results))
}

# Default greedy search.
system.time(feature_search(attributes = names(iris)[-5],
                     fun = evaluator,
                     data = iris))
system.time(feature_search(attributes = names(iris)[-5],
                     fun = evaluator,
                     data = iris,
                     allowParallel = FALSE))

# Optional exhaustive search.
system.time(feature_search(attributes = names(iris)[-5],
                     fun = evaluator,
                     data = iris,
                     mode = "exhaustive"))
system.time(feature_search(attributes = names(iris)[-5],
                     fun = evaluator,
                     data = iris,
                     mode = "exhaustive",
                     allowParallel = FALSE))

# 2) Maximize R^2 statistics in the linear regression model/problem.

evaluator_R2_lm <- function(attributes, data, dependent = names(iris)[1]) {
  summary(
    lm(to_formula(attributes, dependent), data = data)
  )$r.squared
}

feature_search(attributes = names(iris)[-1], fun = evaluator_R2_lm, data = iris,
         mode = "exhaustive")

# 3) Optimize BIC crietion in generalized linear model.
# Aim of Bayesian approach it to identify the model with the highest
# probability of being the true model. - Kuha 2004

utils::data(anorexia, package = "MASS")

evaluator_BIC_glm <- function(attributes, data, dependent = "Postwt") {
  extractAIC(
    fit = glm(to_formula(attributes, dependent), family = gaussian,
              data = data),
    k = log(nrow(data))
  )[2]
}

feature_search(attributes = c("Prewt", "Treat", "offset(Prewt)"),
         fun = evaluator_BIC_glm,
         data = anorexia,
         mode = "exhaustive")

# Close parallelization
stopCluster(cl)
registerDoSEQ()

}
\author{
Zygmunt Zawadzki \email{zygmunt.zawadzki@gmail.com}

Krzysztof Slomczynski \email{krzysztofslomczynski@gmail.com}
}

